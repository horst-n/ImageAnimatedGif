<?php
/**
*  ProcessWire 2.5.x
*  Copyright (C) 2010 by Ryan Cramer
*  Licensed under GNU/GPL v2, see LICENSE.TXT
*
*  http://www.processwire.com
*  http://www.ryancramer.com
*
*
*  This module supports resizing and cropping of animated GIFs when using GD-Library.
*  (The GD-Library do not support this)
*
*  This module is completely based upon the fantastic work of
*
*    * László Zsidi *  (initial classes)
*
*      http://www.gifs.hu/
*      http://www.phpclasses.org/gifsplit
*      http://www.phpclasses.org/gifmerge
*
*    * xurei *  (enhanced classes)
*
*      https://github.com/xurei/GIFDecoder_optimized
*
*
*  and Tommi Forsström (provides usage example)
*
*      http://forssto.com/gifexample/
*      http://stackoverflow.com/users/85702/tommi-forsstr%C3%B6m
*
*
*  ported to PW module by Horst Nogajski
*
*      https://processwire.com/talk/user/1041-horst/
*      https://processwire.com/talk/topic/8386-image-animated-gif/
*      https://processwire.com/talk/topic/8355-animated-gif-images-not-working-after-resize/
*/

class ImageAnimatedGif extends WireData implements Module {

    private $meta = null;

    public function init() {
        $this->pages->addHookBefore('ImageSizer::resize', $this, 'processEventBefore', array('priority'=>1));
    }


    public function processEventBefore(&$event) {
        if (1 != $event->object->imageType) {
            return;  // early return if it isn't a GIF
        }
        if (!$this->isAnimatedGif($event->object->filename)) {
            return;  // early return if it isn't an animated GIF
        }
        // oh dear, I feel a bit 'retro' now: it's an animated GIF
        require_once( __DIR__ . '/libs/gif_decoder.class.php');
        require_once( __DIR__ . '/libs/gif_encoder.class.php');
        $wS = $event->object->image['width'];
        $hS = $event->object->image['height'];
        $wT = $event->arguments[0];
        $hT = $event->arguments[1];
        if (0 == $wT && 0 == $hT) return;
        if (0 == $wT) $wT = ceil(($hT / $hS) * $wS);
        if (0 == $hT) $hT = ceil(($wT / $wS) * $hS);
        $tmpFile = $event->object->filename . '.tmp';
        $resizemethod = (false == $event->object->cropping) ? 2 : 4;
        $this->cropExtra = $event->object->cropExtra;
        $resizemethod = is_array($this->cropExtra) ? 6 : $resizemethod;
        if (@copy($event->object->filename, $tmpFile) && $this->scaleAnimatedGif($event->object->filename, $wS, $hS, $wT, $hT, $tmpFile, $resizemethod)) {
            // we have the resized animated Gif in $tmpFile now
            if (@copy($tmpFile, $event->object->filename)) {
                @unlink($tmpFile);
                $event->replace = true;
                $event->return = true;
                return true;
            }
        }
    }


    private function isAnimatedGif($filename) {
        return (bool) preg_match('/\x00\x21\xF9\x04.{4}\x00(\x2C|\x21)/s', file_get_contents($filename));
    }


    private function prepareGDimage(&$gdimage) {
        return;
        $transparentNew = imagecolorallocate($gdimage, $this->meta['tr'], $this->meta['tg'], $this->meta['tb']);
        $transparentNewIndex = imagecolortransparent($gdimage, $transparentNew);
        imagefill($gdimage, 0, 0, $transparentNewIndex);
    }


    /**
    * $resizemethod:
    *
    * 2 = contain with aspect ratio
    *
    * 4 = resize and crop from center with aspect ratio
    */
    private function scaleAnimatedGif($fileSrc, $fullWidth, $fullHeight, $finalWidth, $finalHeight, $saveTo, $resizemethod = 4) {

        $gif = new GIFdecoder(file_get_contents($fileSrc));
        $this->meta = array(
            'delays'    => $gif->GIFGetDelays(),
            'loops'     => $gif->GIFGetLoop(),
            'disposal'  => $gif->GIFGetDisposal(),
            'tr'        => $gif->GIFGetTransparentR(),
            'tg'        => $gif->GIFGetTransparentG(),
            'tb'        => $gif->GIFGetTransparentB()
        );
        $originalFrames     = $gif->GIFGetFrames();
        $originalFramesMeta = $gif->GIFGetFramesMeta();

        if (count($originalFrames) <= 0) return false;

        for($i = 0; $i < count($originalFrames); $i++) {
            $originalFrames[$i] = imagecreatefromstring($originalFrames[$i]);
        }

        $newFrames = array();
        $intermediateimg = null;

        foreach($originalFrames as $k => $frame) {

            #$newimg = null;
                        //case 3:
                        //    $newimg = imagecreatetruecolor($w, $h);
                        //    imagecopyresampled($newimg, $oldimg, 0, 0, 0, 0, $w, $h, $width, $height);
                        //    break;
//            // cropExtra
//            if (6 == $resizemethod) {
//                // get crop values and create a new intermediate image
//                list($x1, $y1, $w1, $h1) = $this->cropExtra;
//                $tempimg = imagecreatetruecolor($w1, $h1);
//                $this->prepareGDimage($tempimg);  // prepare transparency
//                imagecopy($tempimg, $frame, 0, 0, $x1, $y1, $w1, $h1);
//                unset($x1, $y1, $w1, $h1);
//                $fullWidth = imagesx($tempimg);
//                $fullHeight = imagesy($tempimg);
//                $frame = imagecreatetruecolor($fullWidth, $fullHeight);
//                $this->prepareGDimage($frame);  // prepare transparency
//                imagecopy($frame, $tempimg, 0, 0, 0, 0, $fullWidth, $fullHeight);
//                imagedestroy($tempimg);
//            }

            // contain || resize
            if (2 == $resizemethod || 4 == $resizemethod) {
                $ratio = 1.0;
                $ratio_w = $fullWidth / $finalWidth;
                $ratio_h = $fullHeight / $finalHeight;
                $ratio = ($ratio_h < $ratio_w ? $ratio_h : $ratio_w);  // resize and / or crop
                if (2 == $resizemethod) $ratio = ($ratio_h > $ratio_w ? $ratio_h : $ratio_w);  // contain

                $finalWidth2 = intval($fullWidth / $ratio);
                $finalHeight2 = intval($fullHeight / $ratio);

                $newimg = imagecreatetruecolor($finalWidth2, $finalHeight2);
                $this->prepareGDimage($newimg);  // prepare transparency
                if (is_resource($intermediateimg)) {
                    imagecopy($newimg, $intermediateimg, 0, 0, 0, 0, $finalWidth2, $finalHeight2);
                }

                $srcX = 0; // all frames (but not the first frame) can be a small partial area only
                $srcY = 0;
                $srcW = imageSX($frame);
                $srcH = imageSY($frame);

                $dstX = intval($originalFramesMeta[$k]['left'] / $ratio);
                $dstY = intval($originalFramesMeta[$k]['top'] / $ratio);
                $dstW = intval($originalFramesMeta[$k]['width'] / $ratio);
                $dstH = intval($originalFramesMeta[$k]['height'] / $ratio);

                if (4 == $resizemethod && 1 == $ratio) {
                    imagecopy($newimg, $frame, $dstX, $dstY, $srcX, $srcY, $srcW, $srcH);
                }
                else {
                    imagecopyresampled($newimg, $frame, $dstX, $dstY, $srcX, $srcY, $dstW, $dstH, $srcW, $srcH);
                }
            }

            if (is_resource($newimg)) {
                array_push($newFrames, $newimg);
                if (!is_resource($intermediateimg)) {
                    $intermediateimg = imagecreatetruecolor($finalWidth, $finalHeight);
                    $this->prepareGDimage($intermediateimg);  // prepare transparency
                }
                imagecopy($intermediateimg, $newimg, 0, 0, 0, 0, $finalWidth, $finalHeight);
            }

        }

        if (count($newFrames) > 0) {
            $frames = array();
            foreach($newFrames as $i) {
                ob_start();
                imagegif($i);
                $gifdata = ob_get_clean();
                array_push($frames, $gifdata);
                @imagedestroy($i);
            }

            $gifmerge = new GIFEncoder(
                $frames,
                $this->meta['delays'],
                $this->meta['loops'],
                $this->meta['disposal'],
                $this->meta['tr'], $this->meta['tg'], $this->meta['tb'],
                'bin'
            );

            $result = false === fwrite(fopen($saveTo, 'wb'), $gifmerge->GetAnimation()) ? false : true;
        }
        else {
            $result = false;
        }

        @imagedestroy($frame);
        @imagedestroy($newimg);
        @imagedestroy($intermediateimg);

        return $result;
    }

}
